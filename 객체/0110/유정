과제1. 네임스페이스 활용 코드 만들기
  
#include <iostream>

namespace Calculator {
    int x(int a, int b) {
        return a + b;
    }

    int y(int a, int b) {
        return a * b;
    }
}

int main() {
    std::cout << "3 + 5 = " << Calculator::x(3, 5) << std::endl;
    std::cout << "3 * 5 = " << Calculator::y(3, 5) << std::endl;
    return 0;
}

과제2. 3장 질문
전역 객체와 지역 객체의 생성 및 소멸 순서는 어떻게 달라지나요?

과제3. 3장 요약

객체의 캡슐화:
캡슐화란? 객체의 본질적인 특성을 보호하고 외부로부터 접근을 제한하는 것임.
캡슐화의 목적: 객체 내 데이터에 대한 보안과 보호, 외부 접근 제한
-> 데이터 무결성을 유지한다.
특징: 객체의 일부 요소는 외부와의 인터페이스를 위해 공개될 수 있다.
ex.) TV 객체의 On/Off 버튼, 밝기 조절, 채널 조절 버튼 등이 외부에 노출된다.
# 객체 = 상태 + 행동

객체란? 클래스의 형태를 그대로 가지고 생성되며, 메모리에 실체(instance)로 존재함.
       여러 개의 객체 생성 가능 - 하나의 클래스 틀에서 여러 개의 객체를 생성할 수 있음.

클래스란? 객체를 만들기 위해 정의된 설계도이며, 클래스 자체는 객체가 X.
	  멤버 변수와 멤버 함수 - 클래스 내에서 선언된다.
	  클래스 선언부 + 클래스 구현부로 구성됨.
# 클래스 선언부 : 멤버 변수 & 함수 선언, 멤버에 대한 접근 권한 지정
# 클래스 구현부 : 클래스에 정의된 모든 멤버 함수 구현

접근 지정자
1) private : 동일한 클래스의 멤버 함수에만 접근할 수 있다.
2) public : 모든 다른 클래스에서 접근할 수 있다.
3) protected : 클래스 자신과 상속받은 자식 클래스에만 접근할 수 있다.

접근 지정자의 중요성 : 객체의 데이터 보호와 보안을 위해 접근 지정자를 적절히 사용하는 것이 중요하다.

클래스와 객체의 관계: 클래스는 객체를 생성하기 위한 설계도이며, 객체는 클래스의 인스턴스임.

생성자 : 객체가 생성될 때 자동으로 호출되는 멤버 함수
        객체가 생성될 때 필요한 초기화를 수행한다.

소멸자: 객체가 소멸되는 시점에서 자동으로 호출되는 함수, 메모리 해제 및 정리 작업을 수행한다.

헤더 파일과 cpp 파일 분리 : C++ 프로그램을 작성할 때 클래스 선언부와 구현부를 분리하여 작성하는 것이 바람직함.
목적 : 클래스 재사용성을 높이고, 코드의 가독성을 향상시키기 위함.
조건 컴파일: #ifndef, #define, #endif를 사용하여 헤더 파일의 중복 포함을 방지하는 방법이다.
  
